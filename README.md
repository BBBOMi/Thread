# Thread 정리

## 이 레퍼지토리의 목적

 이 레퍼지토리를 만든 목적은 단순히 내 지식을 정리하자는 것이었다. 하지만 주위에 쓰레드에 대해 잘 모르는 사람들이 많이 있고, 다음 학기에 하는 수업에 프로젝트가 있는데, 그때 설명용을 위해서라도 누군가에게 알려주기 위한 레퍼지토리로 만들어야겠다는 생각을 하였다.  그래서 처음 쓰레드를 접하는 사람이 알 수 있도록 상세하게 적어보면서 스스로도 더 공부를 해야겠다는 생각으로 다시 적어보기로 한다. 그렇기 때문에 완성되기 전에는 많이 더러울 수 있다.

## 목차
 0. 프로세스란?
 1. 쓰레드란?
 2. 쓰레드의 비동기화와 동기화?
 3. 쓰레드의 제어는 어떻게 할까?
 4. 쓰레드 풀이란?
 5. 실제 우리가 사용하는 서버는 어떻게 쓰레드를 사용할까? (톰캣)
 6. 쓰레드 concurrency 패턴들에는 무엇이 있을까?
 7. 쓰레드를 어떻게 사용해야할까?

> 여기서 이야기하는 쓰레드는 모두 자바 쓰레드를 기준으로 한다.

## 0. 프로세스란?

쓰레드를 알기 위해서는 먼저 프로세스를 알아야한다. 프로세스란 메모리 상에 올라가 실행되고 있는 우리들이 만든 프로그램이다. 코드를 작성하여 컴파일과 빌드를 하기만 하면 그것은 프로세스라고 부를 수 없다. 메모리에 올라가 실제로 실행이 되어야 프로세스라고 부를 수 있다.

프로세스가 메모리를 차지하는 영역은 크게 4가지로 나눌 수 있다.

 - 데이터 영역
 - 텍스트(코드) 영역
 - 스택 영역
 - 힙 영역

>  Data 영역을 아직 초기화되지 않은 변수가 있는 BBS(Block Started by Symbol) 영역과 초기화된 변수가 있는 Data 영역으로 나눌 수 있지만 여기서는 크게 4가지 기준으로만 살펴본다.
>  

**데이터 영역**
데이터 영역에는 전역 변수나 static 변수들이 들어가 있다.

**텍스트 영역**
텍스트 영역에는 우리가 작성한 코드가 들어있다. PC(프로그램 카운터)가 가르키고 있는 곳이 이 텍스트 영역에서 다음 실행될 코드가 있는 줄이다.

**스택 영역**
자바 기준으로 메소드가 호출될 때 거기에 있는 지역 변수나 매개 변수가 차지하고 있는 영역이다. 함수가 종료되면 차지하고 있던 영역을 해제한다. 

**힙 영역**
자바 기준으로 new 하면서 객체를 생성할 때 차지하고 있는 영역이다.

> 자바 기준으로 배열은 모두 객체로 생성되기 때문에 힙 영역에 생기지만, C 기준으로 배열은 지역 변수이기 때문에 스택 영역에 생긴다. 그래서 C에서 malloc을 호출하여 배열을 생성하지 않았다면 스택에 차지하게 된다.
> 

**힙과 스택 오버플로우**
데이터 영역과 텍스트 영역은 변할 수가 없기 때문에 처음에 고정되어 있다. 하지만 스택과 힙은 계속해서 변한다. 보통 스택은 컴파일 시에 그 한계 크기가 정해져 있다. 여기서 스택과 힙의 메모리가 어떻게 각 영역을 차지하는지 확인해야한다.

![스택 영역 힙 영역 그림](https://github.com/shouwn/Thread/blob/master/images/statck_heap.gif)


Thread는 코드를 읽어 그걸 실행하는 실행 흐름이다. 

실행 흐름을 알기 전에 평소에 우리가 작성하는 코드의 실행과정을 확인해보자

코드를 작성하고 컴파일을 한 뒤 프로그램을 실행시킨다. 그러면 프로세스가 메모리에 올라가게 된다. 여기까지만 하면 프로그램은 실행되지 않는다. 우리가 평소에 일하는 작업이랑 똑같다. 누군가가 일을 하기 위한 자료나 도구를 책상 위에 올려놓는다고 해서 작업은 시작되지 않는다. 누군가가 그 작업도구로 일을 진행해야만 작업이 이루어진다.  그렇다면 우리가 그 작업자를 지정해주지 않았는데 어떻게 메모리에 올라간 코드들이 실행되는 것일까? 프로세스가 메모리에 올라간 뒤 main Thread 작업자가 그 코드를 실행하기 때문이다. 우리가 명시적으로 Thread 를 만들어주지 않았지만 main Thread는 자동으로 생성되어 진행된다.

 1. 프로세스가 메모리에 올라간다.
 2. main Thread 흐름이 생성된다.
 3. main Thread가 main 메소드를 실행한다.

이와 같이 우리가 평소에 생각하지 않아도 쓰레드는 기본적으로 작동하고 있다.

## 동기와 비동기

 - 동기

어떠한 작업을 한 쓰레드가 담당하여 처리하는 것이 동기이다. 우리가 평소에 쓰레드를 새로 생성하지 않고 작업하는 것이 동기라고 생각하면 된다. main 쓰레드 하나만이 코드를 실행하고 있기 때문이다. 


>나는 동기란 순차적으로 진행하다는 의미로 이해했다. 어떠한 코드를 한 순간에는 하나의 스레드만 읽고 실행한다는 의미이다.

 - 비동기

어떠한 작업을 한 쓰레드가 담당하는 것이 아니라 여러 쓰레드가 동시에 진행하는 것이 비동기이다. 1 부터 1,000까지 혼자서 더하지 말고 1 부터 100, 200 부터 300 ... 900 부터 1,000 까지 10 명의 사람을 동원하여 더하는 것이 비동기적 처리이다. 어떤 작업을 여러 쓰레드가 담당하여 처리하는 것이다.

그런데 여떤 작업을 여러 쓰레드가 담당하면 문제가 생길 수 있다. 어떠한 값을 동시에 수정할 수 있기 때문이다. 이런 것을 방지하기 위해 동기화를 해줘야 한다.

> 하나의 값을 여럿이서 수정하는 문제 외에도 쓰레드가 많으면 다른 여러 문제들이 생길 수 있다. 쓰레드 하나당 메모리가 배정되어야 하기 때문에 메모리 누수 문제가 생길 수 있고 cpu에서 여러 쓰레드를 처리하기 위해 context switching 이 발생하는데 너무 많을 경우 context switching 이 불필요하게 발생하거나 자기 차례가 너무 나중에 돌아와 전체 실행이 느려질 수 있기 때문이다.

 - 동기화

여러 쓰레드가 하나의 메소드를 동시에 호출한다고 가정하자 그런데 그 메소드는 어떠한 값을 바꾸는 메소드였다. 그러면 우리는 그 메소드에 **synchronized** 를 붙여줘 하나의 쓰레드만 접근할 수 있게 만든다. 이렇게 어떠한 작업을 하나의 실행흐름만이 작업하게 하는 것을 동기화라고 한다. 

이렇게 하나의 쓰레드만이 그 메소드를 실행할 수 있게 해주는 것이synchronized인데 그러면 synchronized 는 어떻게 작동할까?

## synchronized
synchronized 는 자바에서 동기화를 지원해주는 키워드이다. synchronized 키워드가 붙어 있는 블럭이나 메소드는 쓰레드가 여럿 들어와도 동기적으로 진행되게 해준다. 내부적으로 진행되는 것을 말하기 전에 간단한 예제를 말해보자.

우리가 공중 화장실을 사용하려고 한다. 공중 화장실이기 때문에 아무나 사용할 수 있다. 하지만 한 순간에 사용할 수 있는 사람은 한 명 뿐이다. 그렇기 때문에 우리는 화장실 문을 잠그고 들어간다. 화장실 문을 잠그면 다른 사람은 들어올 수 없기 때문이다. 그리고 뒤에 사람들은 순서대로 줄을 서서 앞에 사람이 끝나고 잠금을 풀어주기를 기다린다.

위의 예제처럼 화장실 문을 잠그고 줄을 세우고 잠금을 풀어주는 것이 synchronized 키워드가 해주는 일이다. 어떤 쓰레드가 synchronized 키워드가 붙은 구절에 들어가려고 하면 먼저 잠겼는지 확인한다. 잠겼으면 그 쓰레드 흐름을 모니터 대기 큐에 넣는다. 한 마디로 순서대로 들어가게 줄을 세우는 것이다. 그 뒤 앞에 사람이 일을 끝냈으면 잠금을 풀고 다음 사람을 넣어주고 잠근다. 이러한 과정을 프로그래머가 작성하지 않아도 synchronized 키워드만 적어주면 작동한다.

> 모니터 대기 큐라는 것을 알기 위해서는 lock 을 무엇을 기준으로 거는지 알아야 한다. synchronized는 객체를 기준으로 lock을 건다. 그 객체의 ~~~ 에 접근하려면 lock이 걸렸는지 확인하고 그 객체에 접근하려고 했으니 그 객체의 대기 큐에 넣어서 앞에 쓰레드가 일이 끝나면 대기 큐에 들어 있는 쓰레드를 꺼내서 실행시킨다.

## 동기화의 문제

위에 synchronized를 통해서 lock을 사용하여 동기화를 하는 것을 알았다. 하지만 이는 프로그램이 결과를 내는 데에 있어 크리티컬한 문제는 아니지만 성능면에서는 크리티컬한 문제이다. lock을 거는 것이 생각 외로 많은 시간을 잡아먹기 때문이다. lock을 하나 거는 것쯤은 문제가 없다. 하지만 대량의 쓰레드가 하나의 객체에 접근한다고 하면 이 lock을 거는 것은 정말로 큰 문제이다. 그렇기 때문에 어떨 때 동기화를 하고 어떨 때 비동기를 할지 잘 생각해야한다. 그러기 위한 concurrency pattern 들이 있다. 이 레퍼지토리는 사실 이걸 위한 레퍼지토리이다.

