## 스택과 힙 오버플로우

데이터 영역과 텍스트 영역은 변할 수가 없기 때문에 처음에 고정되어 있다. 하지만 스택과 힙은 계속해서 변한다. 보통 스택은 컴파일 시에 그 한계 크기가 정해져 있다. 여기서 스택과 힙의 메모리가 어떻게 각 영역을 차지하는지 확인해야한다.

![스택과 힙 영역](https://github.com/shouwn/Thread/blob/master/images/stack_heap.gif)

보통 운영체제는 한 프로세스에서 다른 프로세스의 메모리 영역을 침범하지 못하도록 한 프로세스가 사용할 수 있는 메모리 영역의 한계선을 정해놓는다. 이 영역 내에서만 메모리를 사용할 수 있다. 그 영역 내에서 그림과 같이 스택과 힙은 같은 영역을 차지하고 있다. 각각 서로 자신이 시작하는 한계선에서 위 혹은 아래로 증가하고 사용을 마치면 영역을 해제하면서 영역을 사용한다. 여기서 만약 스택이 힙의 영역을 침범하면 stack overflow 가 나타난다. 마찬가지로 힙이 계속 증가해서 스택 영역을 침범하면 heap overflow가 일어난다.

흔히 재귀 메소드에 종료 조건을 주지 않았을 때, 메소드가 종료되지 않아 스택이 영역을 해제하지 않고 계속해서 쌓이면 stack overflow가 발생하는 것을 볼 수 있다.

    class A{
	     public void callB(){
		     B b = new B();
		     b = new B();
		     b = new B();
		     b.callA();
	     }
    }
    class B{
	     public void callA(){
		     A[] a = new A[10];
		     a[0] = new A();
		     a[0].callB();
		 }
	}

위와 같은 코드를 작성하였을 때 계속해서 new를 하기 때문에 힙 영역이 차오르고 스택 영역도 계속해서 차오르기 때문에 overflow 에러가 발생한다.

실제로 코드를 작성하여 A 객체를 만들어 callB() 메소드를 호출하면 바로 StackOverflowError 가 발생할 것이다. 

> 개인적으로는 heap overflow를 해보고 싶었지만 실패하였다.

보통은 이런 에러가 일어나기 힘들지만 재귀 메소드를 사용할 때 종료 조건을 안 정해주면 흔히 일어나는 에러이다. 

> 우리가 프로그램을 작성할 때 메모리는 순차적으로 위치한다고 생각한다. 하지만 이건 운영체제가 프로그래머가 메모리를 쉽게 쓸 수 있도록 여기게 하는 가상 메모리이다. 사실 메모리는 운영체제에 의해서 페이지와 세그먼트로 나뉘게 되어 각 메모리가 연속되지 않고 실제 메모리 상에서는 조각내어져 있다.

