
# synchronized

우리들은 스레드 간의 동기화를 위해 synchronized 키워드를 사용한다. 그러면 synchronized 키워드는 어떻게 해서 동기화를 이루게 해줄까? 이 readme에서는 synchronized 가 작동하는 원리와 과정을 보도록 한다. 그 전에 우리가 먼저 알아야 하는 것들이 있다. 세마포어와 lock이다. 이것에 대하 먼저 짧게 이야기 하고 원리와 과정을 말해보도록 한다.

## 세마포어

세마포어는 운영체제 시간에 배우는 것이기 때문에 짧게 말해보려고 한다. 
컴퓨터는 CPU를 통해 무언가를 할 때 계산을 하게 된다. 이 계산이 atomic 한가 아닌가에 따라 컴퓨터는 그 과정을 여러 단계에 걸쳐 진행한다. 

> atomic 하다는 것은 이 연산이 한 클럭에 이루어질 수 있냐는 것과 같다.  1 + 2 + 3 + 4 를 계산한다고 하면 1 + 2를 하고 그 결과에 2 + 3 을 한다. 이렇게 1 ~ 4를 더하려면 여러 단계를 걸쳐야 하기 때문에 atomic 하지 않다. 

세마포어는 내부를 보면 atomic한 연산이 아니지만 atomic 하다고 정해놓은 연산이다. 세마포어를 하는 동안에는 다른 스레드는 세마포어를 실행할 수 없다. 세마포어를 통하여 스레드는 다음 단계의 코드를 실행하거나 이미 다른 스레드가 실행 중이라면 그 스레드는 대기를 하게 된다. 이것을 모니터 라고도 부른다. 그렇기 때문에 여러 스레드가 접근해도 동기적으로 작동할 수 있는 것이다.

> 사실 내부적으로 따지면 위의 내용은 정확하지 않다. 필자의 실력이 모자르기도 하고 세마포어를 자세히 다루기에는 너무 힘들어서 두루뭉실하게나마 이해하도록 적은 것이다.

## lock
lock은 세마포어라고 생각하면 된다. 우리가 공중 화장실에 들어갈 때 문을 잠그면 다른 사람들은 못 들어오는 것처럼 락을 잠그면 다른 스레드는 더 이상 접근할 수 없다.

## 작동 원리
synchronized 의 과정은 매우 간단하다. 스레드가 synchronized 키워드가 적혀 있는 코드를 실행하려고 한다. 그러면 다음의 과정을 따른다.

 1. 먼저 줄을 선다.
 2. 작업 중인 스레드가 없으면 문을 잠그고 작업한다.
 3. 작업 중인 스레드가 있으면 계속 줄은 선다.
 4. 작업 중인 스레드가 거의 끝날 것을 알려준다. 
 5. 서 있던 얘들은 끝날 것을 알고 기다린다.
 6. 작업 중인 스레드가 문을 열고 나온다.
 7. 기다리던 사람들 중 누군가가 들어가서 작업을 한다.

공중 화장실에 비유하면 쉽다. 먼저 화장실에 들어가기 전에 줄을 서고 문을 잠근다. 그러면 문이 잠겼는지 확인하고 잠겼으면 기다린다. 기다리는 동안 잠을 잔다. 그리고 볼 일을 보던 사람이 거의 끝날 것 같다고 알려주면 잠에서 일어나 들어가려고 대기한다. 그 뒤 사람이 나오면 누가 먼저 들어가 문을 잠그고 자기 볼 일을 본다. 이렇게 순차적으로 여러 사람들이 볼 일을 보게 된다.

> 비유하여서 말을 하였지만 정확한 내부 과정은 이렇다. synchronized 키워드가 적혀있는 코드에 접근 하려고 하면 그 객체의 대기 큐에 먼저 들어간다. 만약에 현재 그 코드를 실행하는 스레드가 없으면 큐에서 나와 lock을 걸고 실행하고, 만약에  있으면 현재 작업 중인 스레드가 종료할 때까지 대기 큐에서 기다린다. 그리고 작업 중인 스레드가 거의 일이 끝났으면 작업이 끝날 것 같다고 notify 를 하게 되고 그러면 대기 큐에서 깨어나 작업 중인 스레드가 작업을 끝내고 lock을 풀 때까지 계속 기다린다. 그리고 lock을 풀면 들어가서 lock을 걸고 다시 일을 진행한다. 

이것을 그림으로 하면 다음과 같다.

![enter image description here](https://github.com/shouwn/Thread/blob/master/images/synchronized_lock.gif)

그림을 보았으니 좀 더 자세히 알아보자. synchronized 의 기본적인 작동 과정은 위에서 이해하였다. 그러면 내부적으로 어떻게 처리할까?

먼저 synchronized 가 있는 코드를 실행하려고 하면 그 synchronized 가 있는 코드를 실행 중인 객체의 대기 큐에 들어가게 된다. 이것이 중요하다. 대기큐에 들어가긴 하는데 어느 대기 큐인지 알아야 한다. 

예를 들어 공중 화장실 class 를 구현한 공중 화장실 객체들이 있다. 즉, 여러 공중 화장실이 있는 것이다. 이 공중 화장실에 각각의 사람들이 따로 따로 사용하려고 한다. 그러면 그 사람들이 어디에 줄을 서야 하는가? 자신이 사용하려는 공중 화장실 앞에 서야한다. 

위와 같이 각 스레드는 현재 그 synchronized 코드가 있는 것을 실행할 때 접근하고 있는 객체의 모니터 대기 큐에 들어가게 된다. 그리고 현재 lock이 안 걸려 있다면 자신이 그 코드 안으로 들어가 lock을 걸고 작업을 하게 된다. 그 뒤 새로운 스레드가 와도 먼저 그 객체의 모니터 대기 큐에 들어간다. lock이 걸려 있으면 그 스레드는 일을 안 하고 잠을 자게 된다. 우리가 sleep() 을 호출하는 것과 같이 잠을 잔다. 그런데 잠을 자면 lock이 풀렸는지 모른다. 그렇기 때문에 작업 중인 스레드는 자신이 일을 다 마치기 전에 자고 있는 스레드들을 깨운다. 그러면 그 스레드들은 lock이 풀릴 때까지 이제 일어나서 기다리게 된다. 그리고 lock이 풀리면 다음 스레드가 들어가서 작업을 하게 된다. 이런 과정을 반복한다.

 ## synchronized ( ) { }
synchronized 에는 2가지가 있다. 하나는 { } 로 묶은 부분을 동기적으로 수행하도록 블럭으로 묶은 것이고 다른 하나는 메소드 앞에 synchronized 라고 선언하는 것이다. 먼저 블럭으로 묶은 것부터 보자. 위에 과정에서 설명했듯이 synchronized 는 객체를 통하여 동기화를 시킨다. 그래서 synchronized(객체) 와 같이 어느 객체의 대기 큐에 들어가 lock을 수행할 것인지를 적어주어야 한다. 그리고 그 뒤에 과정은 위와 똑같다.

## synchronized method
다른 하나인 메소드를 살펴보자. 그런데 이건 더 간단하다. 각 메소드가 호출된 this 객체를 기준으로 대기 큐에 들어가고 lock을 거는 것이다. 그 뒤의 과정은 위와 똑같다.

## wait 과 notify, notifyAll
synchronized 말고도 동기화를 위해 제목에 적힌 메소드들을 사용할 수 있다. wait()은 wait()이 호출된 객체의 대기 큐에 들어가 대기하고 notify는 notify를 호출한 객체의 대기 큐에 있는 얘 하나만 깨운다. 그런데 자바의 대기 큐는 운영체제나 JVM이 마음대로 정한 것이기 때문에 무엇이 먼저 깨어날지는 알 수 없다. 무엇일 먼저 깨어날지 알 수 없어 한 스레드가 무기한 연기가 될 수 있다. 그래서 여럿을 깨울 수 있는 메소드가 있는데 그것이 notifyAll 이다 notifyAll을 하면 대기 큐에 있는 모든 스레드들이 깨어난다. 하지만 notifyAll에는 문제가 있다. 바로 race condition이다. 하나의 객체의 lock에 접근하기 위해서 여러 스레드들이 순서 없이 경쟁을 하게 된다. 이러면 무작위로 들어가 무기한 연기는 없을 수 있다. 하지만 여러 스레드가 동시에 일어나 있고 lock을 위해 계속 경쟁을 하기 때문에 오버헤드가 발생한다.
